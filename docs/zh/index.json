[{"categories":["GUI"],"contents":"最近因为某些原因在家🙄，闲时尝试了下egui这个库。感觉是蛮简单的。","date":"2022-12-11T22:27:04+08:00","permalink":"https://virgil-n.github.io/zh/blog/egui%E6%B5%85%E5%B0%9D/","tags":["egui"],"title":"Egui浅尝"},{"categories":["Rust"],"contents":"我们可以使用cfg!宏来告诉编译器当前的配置条件。常用的有：\n键值对类型：target_os、target_arch、target_env、target_family、target_vendor、target_endian、feature等。\n单项类型：test、debug_assertions\n此外，也可以在属性中使用cfg，比如：#[cfg(test)]、#[cfg(windows)]等。还可以使用#[cfg_attr(predicate, attr)]。\neg:\nlet cfg_test = if cfg!(target_os = \u0026#34;macos\u0026#34;) { String::from(\u0026#34;mac\u0026#34;) } else { String::from(\u0026#34;else\u0026#34;) }; println!(\u0026#34;{}\u0026#34;, cfg_test); // mac #[cfg(test)] mod test_mod { #[test] fn just_test() { if cfg!(test) { assert_eq!(1, 1); } else { println!(\u0026#34;...\u0026#34;); } } } ","date":"2022-12-02T17:41:03+08:00","permalink":"https://virgil-n.github.io/zh/blog/rust%E5%AD%A6%E4%B9%A0%E4%B9%8Bcfg%E5%AE%8F/","tags":["cfg!","宏"],"title":"Rust学习之cfg宏"},{"categories":["Rust"],"contents":"Rust迭代器的使用在日常开发中是很基础和重要的，现在了解下迭代器的使用。\n我们获取迭代器有以下几种方法：\n.iter()返回一个迭代器，包含类型的引用 .iter_mut()返回一个迭代器，包含类型的可变引用 .into_iter()返回一个包含类型值的迭代器 迭代器的实现：只需要实现Trait std::iter::Iterator这个trait就行了，不多说了。\n迭代器一般会配合一些集合操作方法，比如rev()，map()，fold()等，学会组合使用会展现出强大的威力。并且相比较for in，loop等循环，迭代器是惰性的，对性能有一定优化。\n注意.into_iter()在receiver为引用的情况下会依情况调用.iter()或.inter_mut()方法。观察以下代码：\n// block 1 // 我们都清楚.into_iter()方法是会转移所有权的，因此下面打印报错在意料之中 let v1 = vec![1, 2, 3]; let i1 = v1.into_iter(); println!(\u0026#34;{:?}, {:?}\u0026#34;, v1, i1); // borrow of moved value: `v1` // block 2 // 有没有一点吃惊😱 let v1 = vec![1, 2, 3]; let i1 = (\u0026amp;v1).into_iter(); println!(\u0026#34;{:?}, {:?}\u0026#34;, v1, i1); // [1, 2, 3] // 或者 let v1 = \u0026amp;vec![1, 2, 3]; let i1 = v1.into_iter(); println!","date":"2022-11-26T15:28:59+08:00","permalink":"https://virgil-n.github.io/zh/blog/rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/","tags":["迭代器"],"title":"Rust学习之迭代器"},{"categories":["Rust"],"contents":"rust注释学习。\n普通注释\n// 单行注释 /* */ 多行注释 文档注释\n/// 单行外部文档注释 /** */ 多行外部文档注释 //! 单行内部文档注释 /*! */ 多行内部文档注释 外部文档注释一般写在代码块前面，内部文档注意一般写在代码块内部。\n注意: crate注释必须使用内部文档注释\n普通注释 外部文档注释 内部文档注释 // /// //! /**/ /** */ /*! */ ","date":"2022-10-11T21:34:09+08:00","permalink":"https://virgil-n.github.io/zh/blog/rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B3%A8%E9%87%8A/","tags":["注释"],"title":"Rust学习之注释"},{"categories":["Rust"],"contents":"rust异步机制学习。\ntokio的线程必须在runtime中运行。 公用代码\nuse chrono::Local; pub fn now() -\u0026gt; String { Local::now().format(\u0026#34;%F %T\u0026#34;).to_string() } 案例代码\nfn main() { println!(\u0026#34;system here\u0026#34;); // rust的线程正常运行 std::thread::spawn(|| { std::thread::sleep(std::time::Duration::from_secs(1)); println!(\u0026#34;thread out block_on: {}\u0026#34;, now()); }); // 报错，只能在tokio的runtime中运行 // tokio::spawn(async { // std::thread::sleep(std::time::Duration::from_secs(1)); // println!(\u0026#34;thread out block_on: {}\u0026#34;, now()); // }); std::thread::sleep(std::time::Duration::from_secs(3)); println!(\u0026#34;system ended: {}\u0026#34;, Local::now().format(\u0026#34;%F %T .%3f\u0026#34;)); } 运行结果(注意打印时间间隔为2秒):\nsystem here\nthread out block_on: 2022-07-11 12:40:54\nsystem ended: 2022-07-11 12:40:56 .478\nblock_on是阻塞的，而enter是非阻塞的(注意查看以下四段代码的运行结果)。 fn main() { let rt1 = tokio::runtime::Runtime::new().","date":"2022-07-11T11:25:36+08:00","permalink":"https://virgil-n.github.io/zh/blog/rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%82%E6%AD%A51/","tags":["异步"],"title":"Rust学习之异步1"},{"categories":["Rust"],"contents":"今天学习rust字符串的push_str方法时发现了一个隐藏的隐患:\n先声明一个\u0026amp;str类型不可变变量 调用此变量的to_string方法并后续直接调用push_str方法 打印此变量 发现变量的值未发生变化，这不是我们想要的， 其实不是这样的，因为to_string方法返回了一个新的String类型，他才是push_str方法的调用者，而s没有发生任何变化，所以最后我们打印的还是“美国”，而且从声明变量时没有加mut而编译器未报错就可以看出，s的值并没有改变。\nlet s = \u0026#34;美国\u0026#34;; s.to_string().push_str(\u0026#34;众神\u0026#34;); println!(\u0026#34;{}\u0026#34;, s); // 美国 中间声明一个可变变量，然后再调用push_str方法\nlet s = \u0026#34;德国\u0026#34;; let mut s2 = s.to_string(); s2.push_str(\u0026#34;希特勒\u0026#34;); println!(\u0026#34;s2: {}\u0026#34;, s2); // 德国希特勒 啊，过了几天再看自己之前写的这篇文章，感觉好low啊！😂\nrust中切片是大小不确定的，无法直接使用，但是切片引用是大小固定的，可以使用。\n切片 切片饮用 str \u0026amp;str [..] \u0026amp;[..] 切片\u0026amp;str虽然可以安全使用，但是，我们很难动态修改其内容 —— 其地址、长度都是固定的。于是 rust 提供了数据类型String。\nString包含了数据指针、数组容量、数据长度等三个字段。如果新修改的数据长度在其容量范围内，数据可以原地修改。如果新修改的数据长度超出了容量范围，它可以重新申请更大的内存。\n于是我们看到，String和\u0026amp;str是两个完全不一样的结构体。为什么字符串要保留这两种形式？原因就是效率。rust希望在数组容量不会变化的时候，用\u0026amp;str。在数组长度可能发生变化的情况下，使用 String。","date":"2022-05-31T14:55:57+08:00","permalink":"https://virgil-n.github.io/zh/blog/rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["字符串"],"title":"Rust学习之字符串"},{"categories":[""],"contents":"爱看书、美剧、电影，热爱生活，关注互联网流行技术。","date":"2022-05-27T14:55:57+08:00","permalink":"https://virgil-n.github.io/zh/page/about/","tags":[""],"title":"关于我"}]