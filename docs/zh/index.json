[{"categories":["Rust"],"contents":"rust异步机制学习。\n tokio的线程必须在runtime中运行  公用代码\nuse chrono::Local;  pub fn now() -\u0026gt; String {  Local::now().format(\u0026#34;%F %T\u0026#34;).to_string() } 案例代码\nfn main() {  println!(\u0026#34;system here\u0026#34;);  // rust的线程正常运行  std::thread::spawn(|| {  std::thread::sleep(std::time::Duration::from_secs(1));  println!(\u0026#34;thread out block_on: {}\u0026#34;, now());  });   // 报错，只能在tokio的runtime中运行  // tokio::spawn(async {  // std::thread::sleep(std::time::Duration::from_secs(1));  // println!(\u0026#34;thread out block_on: {}\u0026#34;, now());  // });   std::thread::sleep(std::time::Duration::from_secs(3));  println!(\u0026#34;system ended: {}\u0026#34;, Local::now().format(\u0026#34;%F %T .","date":"2022-07-11T11:25:36+08:00","permalink":"https://virgil-n.github.io/zh/blog/rust%E5%AD%A6%E4%B9%A0%E4%B9%8Bthread_1/","tags":[""],"title":"Rust学习之thread_1"},{"categories":["Rust"],"contents":"今天学习rust字符串的push_str方法时发现了一个隐藏的隐患:\n 先声明一个\u0026amp;str类型不可变变量 调用此变量的to_string方法并后续直接调用push_str方法 打印此变量  发现变量的值未发生变化，这不是我们想要的\nlet s = \u0026#34;美国\u0026#34;; s.to_string().push_str(\u0026#34;众神\u0026#34;); println!(\u0026#34;{}\u0026#34;, s); // 美国 这是一个隐藏的问题，对此我目前想到的方法时中间声明一个可变变量，然后再调用push_str方法\nlet s = \u0026#34;德国\u0026#34;; let mut s2 = s.to_string(); s2.push_str(\u0026#34;希特勒\u0026#34;); println!(\u0026#34;s2: {}\u0026#34;, s2); // 德国希特勒 ","date":"2022-05-31T14:55:57+08:00","permalink":"https://virgil-n.github.io/zh/blog/rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":[""],"title":"Rust学习之字符串"},{"categories":[""],"contents":"爱看书、美剧、电影，热爱生活，关注互联网流行技术。","date":"2022-05-27T14:55:57+08:00","permalink":"https://virgil-n.github.io/zh/page/about/","tags":[""],"title":"关于我"}]